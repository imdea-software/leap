* Better CUT-OFF
** Less Extra levels for array updates [2013-06-22 Sat] 
  In the cut-off theorm for TSL, an extra level must be added when
  array updates are present: 

  A = B{l<-a}

  Improvement : ONLY one extra level is needed between 
    consecutive array updates. The main idea is that when pumping-up levels,
    one must be able to replicate levels that are *not* the modified level.

    One can choose to replicate the next lower level or can choose to
    replicate the next upper level, but between consecutive array
    update levels none of these choices are good.

    Particular case: if there is only one array update in the formula,
    no extra level needs to be added.

** Implicit levels vs Relevant Levels [2013-06-22 Sat]
   
   Only three normalized literals depend on levels:
    r = addr2set(m,a,l)
    p = getp(m,a1,a2,l)
    A = B {l<-a}
    c = mkcell(e,k,A,l) <- l is implicit here
    skiplist(m,s,a1,a2)
    
    In all cases except skiplist, the level variable is explicit.

    All other levels in the proof (for example 0, maxLevel, and the
    intermediate level added for A=B{l<-a} 
    
    IMPROVEMENT: 
    Do ONLY consider relevant levels in model search.

    In particular, if 0 is not relevant, then take as 0 the first
    higher relevant level, and remove 0 from the search.  If maxLevel
    is not relevant, then take as 0 the first lower relevant level,
    and remove maxLevel from the search.

    JUSTIFICATION:
    Start from a model of the pruned level, and build a model of the
    unpruned level, by copying from relevant levels into implicit
    levels.

** Irrelevant fields [2013-06-22 Sat]
   If there is no query for tids in the formula (as it is in sequential TSL),
   then if there is a model, there is a model in which ALL tids are the same.
   Hence, only one tid needs to be added for the STM search.

   JUSTIFICATION:
   This optimization can be stated as a general theorem in which no
   predicates that depend on tids exist. One starts with a model with
   many tids, replaces all tids for the same tid, and checks that all
   literals in the formula are still satisfied.

* Tactic ideas:
** axiom tactics: [2013-06-13 Thu]
   Give TRUE axioms in a theory and apply them to propagate. 
   For example:  (a in r /\ r_p = r Union b ) |= a in r_p
   Hence, if one has "facts" (literals in the antecedent) of the
   form (a in r) and (r_p = r Union b) one can replace any literal of the form
   (a in r_p) in the antecedent of consequent to "true".
** theory tactics: [2013-06-13 Thu]
   If one has facts F1, .. , Fn in a single theory T (or a fast theory T)
   and formula C also in T, one can query whether
   F1,..,Fn|=C  
   If this is valid, then C can be turned into true.
** split-int-cases: [2013-06-13 Thu]
   consider a set of literals in a formula phi:
   (j op n_i)  where op={ <, <=, =, => , >} and n_i for a variable j
   
   We can split j in all cases (one of : j<n_i, j=n_i j<_ni) for all n_i.

   Then, we can add the conj of literal corresponding to each case and
   propagate. Each resulting VC must be valid (iff the original VC is valid).

   Example:
   (insert_i = maxLevel \/ A ) /\ (insert_i >= maxLevel \/ B) /\ (insert_i = 0 \/ C)
   ->
   (insert_i >= maxLevel \/ D)
   
   The cases are:
      insert_i=0 , 0<insert_i<maxLevel, insert_i=maxLevel, insert_i>maxLevel

   In the last two cases, the consequent becomes true, so the VC is proved.
   In the first case, the resulting VC is:
      A /\ B -> D            [ insert_i = 0 ]
   In the second case:
      A /\ B /\ C -> D       [ 0 < insert_i < maxLevel ]
** filter-levels: [2013-06-13 Thu]
   Let i be the only level ocurring in the consequent.
   Prune from the antecedent all literals that talk about some other level.
   
   Also, if j\neq i (for example j is i+1), turn
      heap_prime = upd(heap,insert_update_k_0[insert_i_k_0],c_prime)
   into 
      heap_prime = heap
** irrelevant-variable-del: [2013-06-13 Thu]
   consider a literal int the antecedent of the form (a=expr), such that
   "a" does not ocurr anywhere else in the formula. Remove the literal.
   Apply recursively until no further remove.

   Let (a = f(b,c)) such that b and c do not ocurr anywhere in the formula.
   Remove the literal.
** irrelevant-predicate-removal: [2013-06-13 Thu]
   This is a fix-point algorithm that computes
   which variables and predicates are relevant.

   Start with the consequent and mark all variables in the consequent
   relevant.
   
   In the antecedent, if there is a predicate of the form:
   a = foo(p), where a is relevant, then p is also relevant, and so is
   the predicate a=foo(p).

-  A variable (a in r) such that a is not relevent (for some other
   reason) is irrelevant. If a is irrelevant, then (a in r) can be
   removed.  Exception: (if a predicate emptyset(r) is present, then
   SOME (a in r) has to be preserved. 

   IDEA: if in the fixpoint r is relevant but a is not, turn (a in r) into
   (~ empty(r)).

- (a = b) should not exist. Equalities are propagated.
- (a != b) is not relevant unless BOTH a and b are
  relevant for other reasons.
- A region r is not relevant unless r occurs in the consequent, or
  an (already) relevant region r2

** remove-irrelevant-levels:
   Let L be the set of relevant levels occurring in the consequent.

   IDEA: Remove all predicates in the antecedent that are "level"
   predicates and refer to non-relevant levels.

   If two levels are not known to be equal (say for variables i and
   j), and only i is relevant then:
   - split A -> C into:
     1. propagate_eq(i=j,A->C)
     2. (i\neq j /\ remove(j,A)->C)
   case 1. handles the models when i and j are equal (in which case whathever
   is said about j is relevant. 
   Case 2 handles when i and j are not equal, in which case whatever is said about 
   j is not so relevant, but the constraint i\neq j may help the validity proof.

   uni

* OLD pre [2013-06-13 Thu] 
** Syntax changes
*** A dot is added to the end of a pogram positions. ie @2. @3[k].
*** Ghost code is surrounded by |[  ]|

** Proposed roadmap
*** Projects
**** Project 1: parse the program [DONE]
**** Project 2: parse invariant candidates [DONE]
**** Project 3: given a program and an invariant, generate all VCs [DONE]
**** Project 4: parse a diagram [DONE]
**** Project 5: generate all VC for a closed diagram [DONE]
**** Project 6: generate all VC for a parametrized diagram

** leap structure
pos_solver -> yicesposquery || z3posquery -> (yices || z3)
num_solver -> yicesnumquery || z3numquery -> (yices || z3) -> smp_num
tll_solver -> yicestllquery || z3tllquery -> (yices || z3) -> smp_tll

** to ask
*** How to implement malloc?
*** Invariant candidates accepts only thread variables as parameters, no fixed thread ids.
*** By the moment, I cannot use boolean variables as conditions. ie while b do ... endwhile
*** Hos to define Enabled function?
*** Should I add an "me" thread identifier? How do we coupe with the ticket mutex program using sets then???

** fix
*** It does not print the ghost code
*** In numeric problems, the transition name may duplicate
*** Change the definition of beta to match cases where arrows go out and in the same box.

** todo
*** Replace fields in VarCell, VarElem... by (variable * kind_t)
*** Add priming to variables as a field of the data type, and not as ' to the variable name
*** Add "min" operation to intSet
*** Add formula parsing to verification diagram in order to obtain the parameter k
*** Resolve the shift/reduce conflict in the parser
*** Add sets as well founded domains for ranking functions in acceptance conditions for verification diagrams
*** Parametrized verification diagrams
*** Add arrays as program variables
*** Add the possibility to add definitions
*** Add function rev and use it in the vd example
*** Generate separate programs: prog2fts, vcgen_closed, vcgen_open, prog2fts --parse
*** List preservation example [DONE]
*** Ranking functions [DONE]
*** Relate a diagram with a program (variables, transitions, ...) [DONE]
*** Skip required between a while and end of program [DONE]
*** Change "-debug" for "--debug" (Deprecated) [DONE]
*** Limit the number of statements that can be ghost or atomic [DONE]
*** Fix the if statement for ghost code [DONE]
*** Test atomic statements [DONE]
*** Add semantic to expressions of the form c.lock() [DONE]
*** The num of threads in a closed system is a param of --vcgen-closed [DONE]
*** Check single assignment within a ghost or atomic code [DONE]
*** Await, critical, noncritical, while ,select code should not be allowed as ghost [DONE]
*** Possibility to define ghost variables [DONE]
*** Ghost assignments can be done only over ghost variables [DONE]
*** Replace the param function with the new one [DONE]
*** Modify to respect ' at the end of a variable when param is called [DONE]
*** I need a function to get primed variables from a formula [DONE]
*** Add to which procedure a variable belongs to [DONE]
*** Rho: statement_t -> th_t option [DONE]
*** Fix the jump position for negative case of if and while [DONE]
*** Modify assignment effects [DONE]
*** Atomic commands [DONE]
*** Variables preservation [DONE]
*** Parametrize rho generation by a thread id [DONE]
*** Prime function [DONE]
*** In the invariant file, I must declare first the tid variables. I will use:
	  tid: i
		 tid j
			 i != j -> .... [DONE]
*** Generate VC for programs [DONE]
*** Define a structure for VD [DONE]
*** Parse VD [DONE]
*** Add atomic statements with different left variable [DONE]
*** Replace && and || by /\ and \/ [DONE]
*** Single procedure programs and local variables are named by "ticket[1]"  (or "MinTicket.ticket[1]") [DONE]
*** Use ticket(i) for parametrized local variables. [DONE]
*** Enrich the parser and VCGen with instructions of the form c.next, c.data, ... [DONE]
*** Generate the invariants with this extended syntax (ensure formulas are building blocks) [DONE]
*** Generate the FTS from the program [DONE]
*** Try with parametrized systems [DONE]
*** Generate VC for diagrams, not just invariant candidates [DONE]
*** Generate output compatible with SAT or SMT solver
*** Modify parser to accept unsorted variables. For instance "x=y" could be equality between integers or sets. Mmm... is this truly necessary? [DONE]
*** Extend parser to parse ghost variables declaration [DONE]
*** Verify that only declared variables are used [DONE]
*** Codify whether a statement is ghost or not inside the statement itself. Perhaps a "ghost : bool" field in options structure? [DONE]
*** Being able to label program lines. c: critial, for instance. [DONE]
