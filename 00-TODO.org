* Better CUT-OFF
** Less Extra levels for array updates [2013-06-22 Sat] 
  In the cut-off theorm for TSL, an extra level must be added when
  array updates are present: 

  A = B{l<-a}

  Improvement : ONLY one extra level is needed between 
    consecutive array updates. The main idea is that when pumping-up levels,
    one must be able to replicate levels that are *not* the modified level.

    One can choose to replicate the next lower level or can choose to
    replicate the next upper level, but between consecutive array
    update levels none of these choices are good.

    Particular case: if there is only one array update in the formula,
    no extra level needs to be added.

		UPDATE:
		Not implemented yet. So far it just checks that there are no two array
		updates in the same formula. If so, Leap crashes.


** Implicit levels vs Relevant Levels [2013-06-22 Sat]
   
   Only three normalized literals depend on levels:
    r = addr2set(m,a,l)
    p = getp(m,a1,a2,l)
    A = B {l<-a}
    c = mkcell(e,k,A,l) <- l is implicit here
    skiplist(m,s,a1,a2)
    
    In all cases except skiplist, the level variable is explicit.

    All other levels in the proof (for example 0, maxLevel, and the
    intermediate level added for A=B{l<-a} 
    
    IMPROVEMENT: 
    Do ONLY consider relevant levels in model search.

    In particular, if 0 is not relevant, then take as 0 the first
    higher relevant level, and remove 0 from the search.  If maxLevel
    is not relevant, then take as 0 the first lower relevant level,
    and remove maxLevel from the search.

    JUSTIFICATION:
    Start from a model of the pruned level, and build a model of the
    unpruned level, by copying from relevant levels into implicit
		levels.

		UPDATE:
		Implemented.


** Irrelevant fields [2013-06-22 Sat]
   If there is no query for tids in the formula (as it is in sequential TSL),
   then if there is a model, there is a model in which ALL tids are the same.
   Hence, only one tid needs to be added for the STM search.

   JUSTIFICATION:
   This optimization can be stated as a general theorem in which no
   predicates that depend on tids exist. One starts with a model with
   many tids, replaces all tids for the same tid, and checks that all
   literals in the formula are still satisfied.

	 UPDATE:
	 Implemented. Tids usually reports domains of 3 elements, considering
	 "NoThread", "me" and "me'" (the tread taking the transition). I think
	 "me" is not used, so maybe we could remove it.


* Tactic ideas:
** axiom tactics: [2013-06-13 Thu]
   Give TRUE axioms in a theory and apply them to propagate. 
   For example:  (a in r /\ r_p = r Union b ) |= a in r_p
   Hence, if one has "facts" (literals in the antecedent) of the
   form (a in r) and (r_p = r Union b) one can replace any literal of the form
   (a in r_p) in the antecedent of consequent to "true".
** theory tactics: [2013-06-13 Thu]
   If one has facts F1, .. , Fn in a single theory T (or a fast theory T)
   and formula C also in T, one can query whether
   F1,..,Fn|=C  
   If this is valid, then C can be turned into true.
** split-int-cases: [2013-06-13 Thu]
   consider a set of literals in a formula phi:
   (j op n_i)  where op={ <, <=, =, => , >} and n_i for a variable j
   
   We can split j in all cases (one of : j<n_i, j=n_i j<_ni) for all n_i.

   Then, we can add the conj of literal corresponding to each case and
   propagate. Each resulting VC must be valid (iff the original VC is valid).

   Example:
   (insert_i = maxLevel \/ A ) /\ (insert_i >= maxLevel \/ B) /\ (insert_i = 0 \/ C)
   ->
   (insert_i >= maxLevel \/ D)
   
   The cases are:
      insert_i=0 , 0<insert_i<maxLevel, insert_i=maxLevel, insert_i>maxLevel

   In the last two cases, the consequent becomes true, so the VC is proved.
   In the first case, the resulting VC is:
      A /\ B -> D            [ insert_i = 0 ]
   In the second case:
      A /\ B /\ C -> D       [ 0 < insert_i < maxLevel ]
** filter-levels: [2013-06-13 Thu]
   Let i be the only level ocurring in the consequent.
   Prune from the antecedent all literals that talk about some other level.
   
   Also, if j\neq i (for example j is i+1), turn
      heap_prime = upd(heap,insert_update_k_0[insert_i_k_0],c_prime)
   into 
      heap_prime = heap
** irrelevant-variable-del: [2013-06-13 Thu]
   consider a literal int the antecedent of the form (a=expr), such that
   "a" does not ocurr anywhere else in the formula. Remove the literal.
   Apply recursively until no further remove.

   Let (a = f(b,c)) such that b and c do not ocurr anywhere in the formula.
   Remove the literal.
** irrelevant-predicate-removal: [2013-06-13 Thu]
   This is a fix-point algorithm that computes
   which variables and predicates are relevant.

   Start with the consequent and mark all variables in the consequent
   relevant.
   
   In the antecedent, if there is a predicate of the form:
   a = foo(p), where a is relevant, then p is also relevant, and so is
   the predicate a=foo(p).

-  A variable (a in r) such that a is not relevent (for some other
   reason) is irrelevant. If a is irrelevant, then (a in r) can be
   removed.  Exception: (if a predicate emptyset(r) is present, then
   SOME (a in r) has to be preserved. 

   IDEA: if in the fixpoint r is relevant but a is not, turn (a in r) into
   (~ empty(r)).

- (a = b) should not exist. Equalities are propagated.
- (a != b) is not relevant unless BOTH a and b are
  relevant for other reasons.
- A region r is not relevant unless r occurs in the consequent, or
  an (already) relevant region r2

** remove-irrelevant-levels:
   Let L be the set of relevant levels occurring in the consequent.

   IDEA: Remove all predicates in the antecedent that are "level"
   predicates and refer to non-relevant levels.

   If two levels are not known to be equal (say for variables i and
   j), and only i is relevant then:
   - split A -> C into:
     1. propagate_eq(i=j,A->C)
     2. (i\neq j /\ remove(j,A)->C)
   case 1. handles the models when i and j are equal (in which case whathever
   is said about j is relevant. 
   Case 2 handles when i and j are not equal, in which case whatever is said about 
   j is not so relevant, but the constraint i\neq j may help the validity proof.

   uni


* Other ideas:

**  Compare arrangements before calling the theory DP:
		When analyzing a formula, we generate a great number of arrangements to try
		over this formula. The arrangement in then reduced to an arrangement
		composed of only relevant levels. The idea is that before calling the DP
		we check whether we have previously checked the formula with an equivalent
		relevant arrangement. If so, we just return the result obtained before and 
		we do not call the DP. Two arrangements A1 and A2 made of relevant levels
		are equivalent iff:
			1) each relevant level l in A1 is also in A2 and vice-versa
			2) order of relevant levels is preserved

		UPDATE:
		Implemented. I have added a table that remembers arrangements of relevant
		levels and their satisfiability value according to the formula. We look up
		in the table before calling the DP.


Instead of calling the DP with each candidate arrangement
		we keep track of the result obtained if we have

**  Use SAT instead of SMT for propositional formulas:
		If the location based formula does not contain information about PC (this
		may be because PC elimination has been applied as tactic to the formula),
		then we have a formula with only boolean variables. This means that we could
		apply CNF over the formula and passed it to a SAT solver instead of an SMT
		solver. This should be faster.

		UPDATE:
		Implemented. Yeap, goes twice as faster =D

**  Improve arrangement generation.
		We are computing many times the same arrangements. That is, starting from
		the same variables and constraints. Idea: Keep a table of already generated
		arrangements. If I am generating arrangements starting from the same set of
		variables and constraints, then just pick the arrangement from the table.

		UPDATE:
		Implemented.

**  Incrementally build the arrangements.
		Usually, all guessed arrangements for conjunctions in DNF coming from the
		same formula will contain the same set of variables. Some of them will have
		more constraint than others. The most constraints it has, the less 
		arrangements it will potentially generate. Hence, I could order the
		arrangements generators by, let's say, constraints, and starting generating
		the most restrictively one, and then start removing conditions according to
		new constraints. Be careful that arrangements are only comparable if they 
		deal with comparable constraints. Disjoint constraints make the arrangements
		incomparable.

** Treat arrangements as trees.
		So I do not need to search on all the arrangements, but perhaps only on a
		branch of the tree.


** Possible tactic for verifying huge programs.
	 When using propagate, we would like to be able to obtain two formulas:

	 i)  An forgetful formula, without the learned literals.

	 ii) A unforgetful formula, for more general cases, containing also the 
			 learned literals.

	 To do this, we would like to implement a propagate_integer_basic which 
	 returns a pair:

	 i)  The forgetful formula (ie. the resulting formula without learned facts)

	 ii) List of learned literals.

	 The forgetful formula (for instance without information regarding PC) is just
	 the first element of the pair, dropping the learned literals. The unforgetful
	 formula is the concatenation of forgetful formula with the learned literals.
	 For example, providing as input the formula:

		 P /\ (P -> Q) /\ (Q /\ P -> R) /\ S -> T

	 propagate_integer_basic returns the pair:

		 (S -> T, (P:: Q::R))

	 propagate_forgetful returns:

		 (S -> T)

	 propagate_unforgetful returns:

		 (P/\ Q/\ R /\ S -> T)

	 Notice that this idea opens the possibility for a faster implementation of
	 the VCGen as we can codify ALL the transition system as a single big RHO in
	 a "lazy" way as:

		if (pc = 1) then rho1
		elseif (pc = 2) then rho2
			...
		elseif (pc = 187635188) then rho187635188

	 Hence, if in another part of the formula we have pc = 37, this big if is
	 then simplified to rho37. We will be doing the conseqution of ALL the system
	 in a sinhle step since we write a huge formula that includes the unfolding of
	 "for all transition as a big disjunction".

	 All this means that for programs with millions of lines, we skip the analysis
	 of silly lines. What in proof by hands we state as: "the only offending
	 transition is 37, so the only interesting VC is this one".


* Progress

** [2013-07-12]
*** Integration of SAT solver to the position solver. The idea is that in some
		cases due to the use of simplification, we can end up with a formula that
		does not speak at all about PC and PCUpdate. Hence, as we have a
		propositional formula we could use SAT instead of SMT. Now, when the flag
		"-sat" is used, if the formula dealing with locations has no info about PC
		then SAT is used instead of SMT. This speeds up the verification using
		Positions Decision Procedure. However, in some cases it may be worst, as
		CNF needs to be computed first and this may blow up.

** [2013-07-15]
*** Checked TSL solver transformation chain. Seems to work properly. Runs over
		problematic transition 42 in about 45 minutes. However it still miss some
		support.
*** Fixed a bug in simplification algorithm at Tactics, which it did not
		consider already used literals in propositional propagation.

** [2013-07-16]
*** Fixed a bug when computing DNF and CNF in Expression and PosExpression.
		It should not affect nothing in the examples we had so far.
*** I have removed the model printer when an empty model is returned (ie.
		no useful information)


** [2013-07-17]
*** Traced a problem to support generation in the concurrent scheme.
*** Implemented lookup table for already analyzed arrangements in order
		to speed-up the verification process.
*** If the formula passed to the satisfiability procedure of TSL is trivially
		satisfiable of unsatisfiable, then no other computations are done. ie:
		 i) (false -> A) and (A -> true) are reduced to true (ie. SAT)
		ii) ~(false -> A) and ~(A -> true) are reduced to false (ie. UNSAT)


** [2013-07-18]
*** Support for skiplist example
*** Check consistency of assumptions in TSL solver


** [2013-07-19]
*** Continuing with the support for skiplist example
*** Log module for Leap


** [2013-07-22]
*** Support ot skiplist example
*** Improvement in the report module, to help in the trace of formula conversion
		and validity verification
*** Program for testing tactics smaller than applytac
*** Fixed bug in simplify_pc tactic


** [2013-07-23]
*** Support for skiplist example
*** Fixed bug in arrangement generation (some invalid arrangements were
		generated.
*** Fixed bug regarding reduction of levels to relevant ones. Level "0"
		was always added despite not being needed in some cases.


** [2013-07-24]
*** Support for skiplist example. Finally transition 42 seems to be valid =)
*** Added information to results report of VC verification



** Next thing to do:
*** Fix support generation for concurrent case. Basically
		local variables are represented as renamed global variables (v[k] -> v_k)
		and the support generator at Tactics consider this variables global,
		generating the support wrong.
*** Write in the ORG the theorems of reduction (white board in Madrid).
*** Connect back the report module, so we have clear information whenever a
		transition is valid or invalid.
*** Finish with the support for Skiplist example.



* OLD pre [2013-06-13 Thu] 
** Syntax changes
*** A dot is added to the end of a pogram positions. ie @2. @3[k].
*** Ghost code is surrounded by |[  ]|

** Proposed roadmap
*** Projects
**** Project 1: parse the program [DONE]
**** Project 2: parse invariant candidates [DONE]
**** Project 3: given a program and an invariant, generate all VCs [DONE]
**** Project 4: parse a diagram [DONE]
**** Project 5: generate all VC for a closed diagram [DONE]
**** Project 6: generate all VC for a parametrized diagram

** leap structure
pos_solver -> yicesposquery || z3posquery -> (yices || z3)
num_solver -> yicesnumquery || z3numquery -> (yices || z3) -> smp_num
tll_solver -> yicestllquery || z3tllquery -> (yices || z3) -> smp_tll

** to ask
*** How to implement malloc?
*** Invariant candidates accepts only thread variables as parameters, no fixed thread ids.
*** By the moment, I cannot use boolean variables as conditions. ie while b do ... endwhile
*** Hos to define Enabled function?
*** Should I add an "me" thread identifier? How do we coupe with the ticket mutex program using sets then???

** fix
*** It does not print the ghost code
*** In numeric problems, the transition name may duplicate
*** Change the definition of beta to match cases where arrows go out and in the same box.

** todo
*** Replace fields in VarCell, VarElem... by (variable * kind_t)
*** Add priming to variables as a field of the data type, and not as ' to the variable name
*** Add "min" operation to intSet
*** Add formula parsing to verification diagram in order to obtain the parameter k
*** Resolve the shift/reduce conflict in the parser
*** Add sets as well founded domains for ranking functions in acceptance conditions for verification diagrams
*** Parametrized verification diagrams
*** Add arrays as program variables
*** Add the possibility to add definitions
*** Add function rev and use it in the vd example
*** Generate separate programs: prog2fts, vcgen_closed, vcgen_open, prog2fts --parse
*** List preservation example [DONE]
*** Ranking functions [DONE]
*** Relate a diagram with a program (variables, transitions, ...) [DONE]
*** Skip required between a while and end of program [DONE]
*** Change "-debug" for "--debug" (Deprecated) [DONE]
*** Limit the number of statements that can be ghost or atomic [DONE]
*** Fix the if statement for ghost code [DONE]
*** Test atomic statements [DONE]
*** Add semantic to expressions of the form c.lock() [DONE]
*** The num of threads in a closed system is a param of --vcgen-closed [DONE]
*** Check single assignment within a ghost or atomic code [DONE]
*** Await, critical, noncritical, while ,select code should not be allowed as ghost [DONE]
*** Possibility to define ghost variables [DONE]
*** Ghost assignments can be done only over ghost variables [DONE]
*** Replace the param function with the new one [DONE]
*** Modify to respect ' at the end of a variable when param is called [DONE]
*** I need a function to get primed variables from a formula [DONE]
*** Add to which procedure a variable belongs to [DONE]
*** Rho: statement_t -> th_t option [DONE]
*** Fix the jump position for negative case of if and while [DONE]
*** Modify assignment effects [DONE]
*** Atomic commands [DONE]
*** Variables preservation [DONE]
*** Parametrize rho generation by a thread id [DONE]
*** Prime function [DONE]
*** In the invariant file, I must declare first the tid variables. I will use:
	  tid: i
		 tid j
			 i != j -> .... [DONE]
*** Generate VC for programs [DONE]
*** Define a structure for VD [DONE]
*** Parse VD [DONE]
*** Add atomic statements with different left variable [DONE]
*** Replace && and || by /\ and \/ [DONE]
*** Single procedure programs and local variables are named by "ticket[1]"  (or "MinTicket.ticket[1]") [DONE]
*** Use ticket(i) for parametrized local variables. [DONE]
*** Enrich the parser and VCGen with instructions of the form c.next, c.data, ... [DONE]
*** Generate the invariants with this extended syntax (ensure formulas are building blocks) [DONE]
*** Generate the FTS from the program [DONE]
*** Try with parametrized systems [DONE]
*** Generate VC for diagrams, not just invariant candidates [DONE]
*** Generate output compatible with SAT or SMT solver
*** Modify parser to accept unsorted variables. For instance "x=y" could be equality between integers or sets. Mmm... is this truly necessary? [DONE]
*** Extend parser to parse ghost variables declaration [DONE]
*** Verify that only declared variables are used [DONE]
*** Codify whether a statement is ghost or not inside the statement itself. Perhaps a "ghost : bool" field in options structure? [DONE]
*** Being able to label program lines. c: critial, for instance. [DONE]
