
vars:

invariant [skiplist_order_inst] :


///////////  Insert  /////////////


#insert_update_i_data_bounded:
   @insert_update_upper_bounds. ->
      (insert::i <= maxLevel ->
          (rd(heap,insert::update[insert::i]).data < insert::e /\
           rd(heap,rd(heap,insert::update[insert::i]).arr[insert::i]).data > insert::e))


#insert_update_data_lower_than_e:
   (@insert_final_if_condition. /\ 0 <= maxLevel) ->
      rd(heap,insert::update[0]).data < insert::e


   @insert_newCell_next_connected. ->
      ((insert::i <= maxLevel) ->
        (rd(heap,insert::update[insert::i]).data < insert::e /\
         rd(heap,rd(heap,insert::update[insert::i]).arr[insert::i]).data > insert::e))


///////////  Remove  /////////////


///\ @remove_final_loop_begins. ->
//      (0 <= remove::i ->
//         (rd(heap, rd(heap, remove::update[remove::i]).arr[remove::i]).data > remove::e \/
//          rd(heap, rd(heap, remove::update[remove::i]).arr[remove::i]).data = remove::e))


///\ @remove_section. ->
//      ((0 <= remove::i /\ remove::i <= maxLevel) ->
//        remove::update[remove::i] in addr2set(heap, head, remove::i))


#remove_update_i_lower:
   (@remove_section. /\ remove::i <= remove::removeFrom) ->
      rd(heap, remove::update[remove::i]).data < remove::e

