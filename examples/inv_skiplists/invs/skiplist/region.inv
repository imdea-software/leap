vars:

int j

invariant [skiplist_region] :

   @39. -> (~ insert::newCell in region)

/\ @insert_prev_in_region. -> insert::prev in region

/\ @insert_curr_in_region. -> insert::curr in region

/\ @insert_newCell_created. -> insert::newCell != null

/\ (@32. \/ @33.) -> insert::curr != null

/\ (@29. \/ @30. \/ @33.) -> rd(heap, insert::prev).arr[insert::i] in region

/\ @insert_i_eq_max. -> rd(heap, insert::curr).arr[maxLevel] in region

///\ @insert_bounded_i_one. -> rd(heap, insert::prev).arr[insert::i] in region

/\ (@31. \/ @32.) -> insert::curr in region

/\ (@42. \/ @43.) -> (insert::i = maxLevel \/ ~ insert::newCell in addr2set(heap, head, insert::i + 1))

/\ @43. -> insert::newCell in addr2set(heap, head, insert::i) 

/\   @insert_newCell_unconnected. -> (insert::i >= maxLevel \/ ~ insert::newCell in addr2set(heap, head, insert::i))

/\   @insert_newCell_low_connected. ->
          ((insert::i = 0 \/ insert::newCell in addr2set(heap, head, insert::i - 1)) /\
            insert::update[insert::i] in region
             )


///// For update array

/\   (@insert_update_higher. /\ insert::i < j /\ j <= maxLevel) -> insert::update[j] in region
/\    @insert_update_set. -> insert::update[insert::i] = insert::prev

/\   (@insert_update_all_set. /\ 0 <= j /\ j <= maxLevel) -> insert::update[j] in region


///// For update array


/\ @remove_curr_in_region. -> remove::curr in region

/\   @61. -> (remove::curr in region /\
              (remove::i = maxLevel \/ ~ (remove::curr in addr2set(heap, head, remove::i + 1))) /\
              (remove::update[remove::i] in region)
             )
