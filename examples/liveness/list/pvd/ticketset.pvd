Diagram[list]

Nodes: n0 { ~ @ins_working(k). },
			 n1 { rd(heap,lastlocked(heap,getp(heap,head,null))).lockid = t /\
						(@ins_working(t). \/ @rem_working(t). \/ sch_working(t).)  },
			 n2 { rd(heap,lastlocked(heap,getp(heap,head,null))).lockid = k /\
						@ins_prev_advance(k). },
			 n3 {rd(heap,lastlocked(heap,getp(heap,head,null))).lockid = k /\ 
						@ins_lock_curr(k). },
			 n4 { rd(heap,lastlocked(heap,getp(heap,head,null))).lockid = k /\
						@ins_insertion_process(k). },
			 n5 { rd(heap,lastlocked(heap,getp(heap,head,null))).lockid = k /\
						@ins_return(k). }


Boxes: {b1[t]:n1,n2}

Initial: n0

Edges:  n0 -{23(k)}-> n1;
				n0 -{23(k)}-> n3;
				n1 -{20(t), 37(t), 53(t)}-> n1;
				n1 -{20(t), 37(t), 53(t)}-> n2;
				n2 -{30(k)}-> n3;
				n3 -{31(k)}-> n2;
				n2 -{26(k)}-> n4;
				n4 -{37(k)}-> n5;
				n5 -{38(k)}-> n0;
	// Self-loops
        n0 --> n0;
			 [n1 --> n1];
				n2 --> n2;
				n3 --> n3;
				n4 --> n4;
        n5 --> n5;

Acceptance:
	<<Bad :{(n1,n1,any),(n1,n2,any),(n1,n3,any),(n1,n4,any),(n1,n5,any),(n2,n3,any)};
		Good:{(n0,n1,any),(n0,n2,any),(n5,n0,any),(n0,n0,any)};
    (splower(bag,main::ticket(k)), pairsubset_op) >>

