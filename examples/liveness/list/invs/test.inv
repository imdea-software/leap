vars:

tid j

invariant [test] :

#owns_a_lock:
  (@sch_working(j). \/ @ins_working(j). \/ @rem_working(j).) =
		tin (j, lockset(heap, getp(heap, head, null)))

#test:
	(@ins_working(k). /\
	 ~@ins_releases_last_lock(k).) ->
			aheadSet = tdiff (lockset(heap, getp(heap, rd(heap, insert::prev(k)).next, null)), tsingle(k))


//#test:
//	((@ins_init_prev_locked(k). \/
//		@ins_lock_curr(k).) ->
//			aheadSet = lockset(heap, getp(heap, rd(heap, insert::prev(k)).next, null))) /\
//
//	((@ins_prev_curr_locked(k). \/
//		@ins_aux_before_prev(k). \/
//		@ins_only_curr_locked(k). \/
//		@ins_insertion_process(k). \/
//		@ins_releases_last_lock(k). ) ->
//			aheadSet = lockset(heap, getp(heap, rd(heap, insert::curr(k)).next, null)))



// THIS WAS UNCOMMENTED
//	(~@ins_working(k). \/
//	 @ins_releases_last_lock(k).) ->
			insideSet = lockset(heap, getp(heap, head, null))

	 (@ins_working(j). /\
		~@ins_elem_inserted(j). /\
		tin(j, lockset(heap, getp(heap, head, null)))) ->
		tin(j, insideInsert)

// THIS WAS UNCOMMENTED
//	((~@ins_working(k). \/
//		@ins_releases_last_lock(k).) /\
//		@ins_working(j). /\
//		~@ins_elem_inserted(j). /\
//		tin(j, lockset(heap, getp(heap, head, null)))) ->
//		tin(j, insideInsert)


//	(~@ins_working(k). \/
//	 @ins_releases_last_lock(k).) ->
//			insideSet = lockset(heap, getp(heap, head, null))

#newtest:
	(@ins_working(k). /\
	 ~@ins_releases_last_lock(k). /\
	 @ins_working(j). /\
	 ~@ins_elem_inserted(j). /\
	 j != k /\
	 tin(j, lockset(heap, getp(heap, rd(heap, insert::prev(k)).next, null)))) ->
		tin(j, aheadInsert)



//#newtesttwo:
//	(@ins_working(k). /\
//	 @rem_working(j). /\
//	 tin(j, lockset(heap, getp(heap, insert::prev(k), null)))) ->
//		tin(j, aheadSet)

#aa:
	@ins_last_prev_unlock(j). ->
		(rd(heap, insert::prev(j)).next = insert::curr(j) \/
		 (rd(heap, insert::prev(j)).next = insert::aux(j) /\
			rd(heap, insert::aux(j)).next = insert::curr(j) /\
			rd(heap, insert::aux(j)).lockid = #))

