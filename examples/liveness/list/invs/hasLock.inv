
vars:

tid j

invariant [hasLock] :

#owns_a_lock:
   (@sch_working(j). \/ @ins_working(j). \/ @rem_working(j).) =
      tin (j, lockset(heap, getp(heap, head, null)))

#search_thread_ahead:
  (@sch_working(j). /\
   (@ins_working(k). /\ ~ @ins_releases_last_lock(k).)) -> tin (j, aheadSet)

#insert_thread_ahead:
  (@ins_working(j). /\
   (@ins_working(k). /\ ~ @ins_releases_last_lock(k).)) -> tin (j, aheadSet)

#remove_thread_ahead:
  (@rem_working(j). /\
   (@ins_working(k). /\ ~ @ins_releases_last_lock(k).)) -> tin (j, aheadSet)

#insert_thread_inserting_ahead:
  (@ins_working(j). /\
   (@ins_working(k). /\ ~ @ins_releases_last_lock(k).)) -> tin (j, aheadInsert)


#test:
  (@ins_working(k). /\ ~ @ins_releases_last_lock(k).) -> rd(heap, head).lockid = k
